function [mask_skele,skeleton,is_converg] = skele_learn_single_layer_d(dataset,init_skele,condset_size,alpha,mask_rate)
% Learn a new mask skeleton based on the skeleton obtained in the previous layer, only supporting discrete datasets

skeleton=init_skele;

vari_pair_CI1={}; % Store pairs of independent variables
p_max_list_CI1=[]; % Store a list of the maximum p-values generated by independent variables

is_converg=1;
[X,Y] = find(skeleton);
for i=1:length(X)
    x = X(i); y = Y(i);
    
    if skeleton(x,y) ~= 0
        nbrs = mysetdiff(myneighbors(skeleton, y), x);
        if length(nbrs) >= condset_size
            is_converg=0;
            SS = subsets1(nbrs, condset_size);
            p_CI1=[]; % Store p-values that make two variables conditional independent
            for si=1:length(SS)
                S = SS{si};
                
                ns=max(dataset);
                [pval]=my_g2_test(x,y,S,dataset,ns,alpha);
                if isnan(pval)
                    CI=0;
                else
                    if pval<=alpha
                        CI=0;
                    else
                        CI=1;
                    end
                end
                
                if(CI==1)
                    skeleton(x,y) = 0;
                    skeleton(y,x) = 0;
                    p_CI1=[p_CI1 pval];
                end
            end
            if ~isempty(p_CI1)
                vari_pair_CI1{end+1}=[x,y];
                p_max_list_CI1=[p_max_list_CI1 max(p_CI1)];
            end
        end
    end
end

% mask skeleton
mask_skele=skeleton;

if ~isempty(vari_pair_CI1)
    mask_num=ceil(mask_rate*length(vari_pair_CI1)); % Calculate the number of independent relationships that require a mask
    [~, indices] = sort(p_max_list_CI1); % Ascending order
    for i=1:mask_num
        mask_skele(vari_pair_CI1{indices(i)}(1),vari_pair_CI1{indices(i)}(2))=-1;
        mask_skele(vari_pair_CI1{indices(i)}(2),vari_pair_CI1{indices(i)}(1))=-1;
    end
end


end
