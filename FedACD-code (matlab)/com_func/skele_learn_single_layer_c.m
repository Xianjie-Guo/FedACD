function [mask_skele,skeleton,is_converg] = skele_learn_single_layer_c(dataset,init_skele,condset_size,alpha,mask_rate)
% Learn a new mask skeleton based on the skeleton obtained in the previous layer, which only supports continuous datasets

skeleton=init_skele;

vari_pair_CI1={}; % Store pairs of independent variables
r_min_list_CI1=[]; % Store a list of the minimum r values generated by independent variables

is_converg=1;
[X,Y] = find(skeleton);
for i=1:length(X)
    x = X(i); y = Y(i);
    
    if skeleton(x,y) ~= 0
        nbrs = mysetdiff(myneighbors(skeleton, y), x);
        if length(nbrs) >= condset_size
            is_converg=0;
            SS = subsets1(nbrs, condset_size);
            r_CI1=[]; % Store r values that make two variables conditional independent
            for si=1:length(SS)
                S = SS{si};
                
                [CI,r]=my_fisherz_test(x,y,S,dataset,size(dataset,1),alpha);
                if isnan(CI)
                    CI=0;
                end
                
                if(CI==1)
                    skeleton(x,y) = 0;
                    skeleton(y,x) = 0;
                    r_CI1=[r_CI1 r];
                end
            end
            if ~isempty(r_CI1)
                vari_pair_CI1{end+1}=[x,y];
                r_min_list_CI1=[r_min_list_CI1 min(r_CI1)];
            end
        end
    end
end

% mask the skeleton
mask_skele=skeleton;

if ~isempty(vari_pair_CI1)
    mask_num=ceil(mask_rate*length(vari_pair_CI1)); % Calculate the number of independent relationships that require a mask
    [~, indices] = sort(r_min_list_CI1, 'descend'); % Sort in descending order
    for i=1:mask_num
        mask_skele(vari_pair_CI1{indices(i)}(1),vari_pair_CI1{indices(i)}(2))=-1;
        mask_skele(vari_pair_CI1{indices(i)}(2),vari_pair_CI1{indices(i)}(1))=-1;
    end
end


end